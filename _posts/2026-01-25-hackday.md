---
title: Qualifications HackDay - Writeups
time: 2026-01-25 12:00:00 
categories: [ctf]
tags: [web,crypto,stegano,forensic,Network,misc, web3, Programmation]
image: /assets/posts/hackday/hackday.gif
---

Mes writeups pour les challenges que j'ai r√©solu lors de la phase des qualifications Hackday CTF. 

![](/assets/posts/hackday/solve.png)

# Forensic

## Ringbearer 

![Ringbearer ](/assets/posts/hackday/Ringbearer.png)

``File`` : [Ringbearer.zip](/assets/posts/hackday/Ringbearer.zip) 

### Challenge Description

> You are the ringbearer, you carry a burden that must never fall into the wrong hands. Many who once walked beside you are no longer found in the present records. Yet one faithful companion never left your side. What remains beside the Ringbearer may hold the key to secrets long forgotten. The one who never left the Ringbearer's side is the user that we searching for, can you find him?


Apr√®s avoir extrait l'archive, nous d√©couvrons la structure suivante :

```bash
$ tree Ringbearer/
.
‚îú‚îÄ‚îÄ Desktop
‚îÇ   ‚îî‚îÄ‚îÄ 7zPasswordFormat.txt
‚îú‚îÄ‚îÄ Documents
‚îÇ   ‚îî‚îÄ‚îÄ old
‚îÇ       ‚îú‚îÄ‚îÄ 317f1e761f2faa8da781a4762b9dcc2c5cad209a.bak
‚îÇ       ‚îú‚îÄ‚îÄ 8eec7bc461808e0b8a28783d0bec1a3a22eb0821.bak
‚îÇ       ‚îú‚îÄ‚îÄ c981d125d1a564c9f5738faff51d59d98711f145.bak
‚îÇ       ‚îú‚îÄ‚îÄ f16bed56189e249fe4ca8ed10a1ecae60e8ceac0.bak
‚îÇ       ‚îî‚îÄ‚îÄ f873f39163f5b43dbf1fee63cbce284074896221.bak
‚îú‚îÄ‚îÄ Downloads
‚îÇ   ‚îú‚îÄ‚îÄ Invitation.7z
‚îÇ   ‚îî‚îÄ‚îÄ notes.txt
‚îî‚îÄ‚îÄ System32
    ‚îú‚îÄ‚îÄ driver
    ‚îú‚îÄ‚îÄ sam
    ‚îú‚îÄ‚îÄ security
    ‚îú‚îÄ‚îÄ software
    ‚îî‚îÄ‚îÄ system
```

En faisant un file sur les fichiers, on remarque un point essential le fichier `f873f39163f5b43dbf1fee63cbce284074896221.bak`n'est pas un fichier de registre system mais une archive contenant `flag.txt` 

Examinons les indices textuels :

```bash
$ cat Desktop/7zPasswordFormat.txt
Expected a pair separated by @, an identity bound to its secret.

$ cat Downloads/notes.txt
You are not invited !
```

Le format du mot de passe est clairement d√©fini : `username@password`.



### √âtape 1 : Extraction des hashes du SAM actuel

Utilisons `impacket-secretsdump` pour extraire les hashes NTLM :

```bash
$ impacket-secretsdump -sam System32/sam -system System32/system LOCAL

[*] Target system bootKey: 0x3e0fb360762ca6d969cfac8038281b09
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:209c6174da490caeb422f3fa5a7ae634:::
guest:501:aad3b435b51404eeaad3b435b51404ee:5591dab10212457bbce3c99927ed7bc0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:e5785e26e90569fee749be90b1c6a7a6:::
ringbearer:1001:aad3b435b51404eeaad3b435b51404ee:5e8a41106cf5fece3ab30d2f668c886f:::
```

Le message du notes.txt mentionnait une invitation.

En prenant le hash NTLM de `guest` : `5591dab10212457bbce3c99927ed7bc0`

Sur [CrackStation](https://crackstation.net/), nous obtenons : **`youareinvited`**

![guest hash](/assets/posts/hackday/guest.png)

### √âtape 2 : D√©chiffrement de l'invitation

Avec le format `username@password` et le message "You are not invited", j'ai essay√© des combinaisons et ceci passe `guest@youareinvited` :

```bash
$ 7z x Downloads/Invitation.7z -p"guest@youareinvited"

Extracting archive: Downloads/Invitation.7z
Everything is Ok

$ cat hint.txt
The user you've been searching for once said this: 
"I Can't Carry It For You... But I Can Carry You!"
```

### √âtape 3 : Analyse du hint - R√©f√©rence au Seigneur des Anneaux

Cette citation embl√©matique provient de **Samwise Gamgee** (Sam), le fid√®le compagnon de Frodo dans *Le Seigneur des Anneaux*. Le challenge indique que certains utilisateurs "are no longer found in the present records" - 

### √âtape 4 : Identification des anciennes sauvegardes de registre

Utilisons `hivexsh` pour identifier le type de chaque fichier `.bak` :

```bash
$ hivexsh Documents/old/c981d125d1a564c9f5738faff51d59d98711f145.bak
> ls
7-Zip, Classes, Microsoft, Windows...
‚Üí SOFTWARE

$ hivexsh Documents/old/8eec7bc461808e0b8a28783d0bec1a3a22eb0821.bak
> ls
Cache, Policy, RXACT
‚Üí SECURITY

$ hivexsh Documents/old/317f1e761f2faa8da781a4762b9dcc2c5cad209a.bak
> ls
ControlSet001, Select, Setup...
‚Üí SYSTEM

$ hivexsh Documents/old/f16bed56189e249fe4ca8ed10a1ecae60e8ceac0.bak
> ls
SAM
‚Üí SAM (ancienne version !)

$ file Documents/old/f873f39163f5b43dbf1fee63cbce284074896221.bak
‚Üí 7-zip archive data (le flag !)
```

### √âtape 5 : Extraction des hashes de l'ancien SAM

Maintenant que nous avons identifi√© l'ancien SAM et SYSTEM, extrayons les hashes :

```bash
$ impacket-secretsdump \
  -sam Documents/old/f16bed56189e249fe4ca8ed10a1ecae60e8ceac0.bak \
  -system Documents/old/317f1e761f2faa8da781a4762b9dcc2c5cad209a.bak \
  LOCAL

[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:209c6174da490caeb422f3fa5a7ae634:::
guest:501:aad3b435b51404eeaad3b435b51404ee:5591dab10212457bbce3c99927ed7bc0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:e5785e26e90569fee749be90b1c6a7a6:::
ringbearer:1001:aad3b435b51404eeaad3b435b51404ee:5e8a41106cf5fece3ab30d2f668c886f:::
gandalftw:1012:aad3b435b51404eeaad3b435b51404ee:98815f8c88e7b2dcf5603d14ef48f3f2:::
samwiseg:1013:aad3b435b51404eeaad3b435b51404ee:dcd99365563e67eb8fbe8c9d83b0ca6c:::
aragornii:1014:aad3b435b51404eeaad3b435b51404ee:9146cf0dfda2169b163869bedb8457ae:::
legolasg:1015:aad3b435b51404eeaad3b435b51404ee:91268860a660d8cff4aef11b6550c11e:::
```

**Excellent !** Nous trouvons l'utilisateur **`samwiseg`** (Samwise Gamgee) avec le hash : `dcd99365563e67eb8fbe8c9d83b0ca6c`.
C'est le seul user qui ne pas soit pas pr√©sent le nouveau mais visible dans les anciennes sauvegardes de registre.

### √âtape 6 : Cracking du hash de samwiseg

Sur CrackStation avec le hash `dcd99365563e67eb8fbe8c9d83b0ca6c`, nous obtenons : **`TheHelper`**

![sam hash](/assets/posts/hackday/sam.png)

### √âtape 7 : Extraction du flag

Utilisons maintenant les credentials au format attendu :

```bash
$ 7z x Documents/old/f873f39163f5b43dbf1fee63cbce284074896221.bak -p"samwiseg@TheHelper"

Extracting archive: Documents/old/f873f39163f5b43dbf1fee63cbce284074896221.bak
Everything is Ok

Files: 1
Size: XX
Compressed: 186

$ cat flag.txt

```
**Flag:** `HACKDAY{TH4nk_Y0u_s4M_G4mg3e} `

## Y2K patch 

![Y2K patch](/assets/posts/hackday/patch.png)

``File`` : [floppy_backup.img](/assets/posts/hackday/floppy_backup.img) 

### Challenge Description

> Our team managed to steal a floppy disk labelled "Project Epoch" from the company Millennium Systems. It was found in the computer of an employee that was working on a patch for the Y2K bug but mysteriously disappeared a week ago.

>Find out what might have happened.



Commen√ßons par examiner ce que nous avons :

```bash
$ file floppy_backup.img
floppy_backup.img: DOS/MBR boot sector, code offset 0x3c+2, OEM-ID "mkfs.fat", 
root entries 224, sectors 2880 (volumes <=32 MB), sectors/FAT 9, sectors/track 18, 
serial number 0x4ebf2d79, label: "Y2K_BACKUP ", FAT (12 bit), followed by FAT
```

Nous avons une image de disquette FAT12 - un support de stockage classique de l'√®re Y2K. 

---

### Investigation Forensique avec Autopsy

### Montage de l'Image

J'ai lanc√© Autopsy pour effectuer l'analyse :

```bash
$ sudo autopsy
```

Apr√®s avoir cr√©√© un nouveau cas, j'ai import√© `floppy_backup.img` en tant que partition FAT.

![importimage1](/assets/posts/hackday/import1.png)
![importimage2](/assets/posts/hackday/import2.png)

### D√©couverte de Fichiers Supprim√©s

Le listing des fichiers a r√©v√©l√© plusieurs entr√©es int√©ressantes :

| Nom | √âcrit | Acc√©d√© | Cr√©√© | Taille | Meta |
|-----|-------|--------|------|--------|------|
| $FAT1 | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 | 4608 | 45780 |
| $FAT2 | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 | 4608 | 45781 |
| $MBR | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 | 512 | 45779 |
| confessions.txt | 1999-12-24 13:28:54 | 1999-12-24 00:00:00 | 1999-12-24 13:28:55 | 132 | 11 |
| **export.zip** | **1999-12-24 13:28:54** | **1999-12-24 00:00:00** | **1999-12-24 13:28:55** | **3346** | **8** |
| **to-do_list.txt** | **1999-12-24 13:28:54** | **1999-12-24 00:00:00** | **1999-12-24 13:28:55** | **321** | **6** |
| Y2K_BACKUP | 1999-12-24 14:28:10 | 1999-12-24 00:00:00 | 1999-12-24 14:28:10 | 0 | 3 |

Les fichiers marqu√©s comme **r/r** indiquent des fichiers supprim√©s ! Deux fichiers  ont √©t√© effac√©s :
- `export.zip` (3346 octets)
- `to-do_list.txt` (321 octets)

![importimage3](/assets/posts/hackday/import3.png)

### La Note de Confession

La lecture de `confessions.txt` r√©v√®le :

```
Dear Millennium Systems,

I deleted everything. You will not get this "patch" running. 
The world deserves to know what you're doing.
```

### R√©cup√©ration des Fichiers Supprim√©s

En utilisant la fonction d'export d'Autopsy, j'ai r√©cup√©r√© les deux fichiers supprim√©s dans mon r√©pertoire de travail.

---

### Analyse des Fichiers R√©cup√©r√©s

```bash
$ cat to-do_list.txt
```

```
- zip "patch" and personnal file
- password protect with strong password
- exfiltrate it on personnal drive
- delete patch from company servers
- delete evidences
- Reveal everything to the press
- get to dentist appointment at 5pm
- buy gift for wife
- go watch The Matrix at movie theater
- train hard for Hackday 2000
```

```bash
$ unzip export.zip
Archive:  export.zip
[export.zip] to-do_list.txt password: 
   skipping: to-do_list.txt          incorrect password
   skipping: Y2K_PATCH.bin           incorrect password
```

L'archive contient :
- `to-do_list.txt` (que nous avons en clair !)
- `Y2K_PATCH.bin` 

Les deux fichiers sont prot√©g√©s par mot de passe.

---

V√©rifions la m√©thode de chiffrement :

```bash
$ 7z l -slt export.zip | grep Method
Method = ZipCrypto Deflate
Method = ZipCrypto Deflate
```

**ZipCrypto** est vuln√©rable aux attaques know plaintext! Puisque nous avons la version en clair de `to-do_list.txt`, nous pouvons exploiter cette faiblesse.

Nous devons cr√©er un fichier ZIP avec des **param√®tres de compression identiques** :

```bash
$ zip -9 plain.zip to-do_list.txt
  adding: to-do_list.txt (deflated 36%)
```

#### Pourquoi Utiliser la Compression `-9` ?

Le flag `-9` dans zip cr√©e le **niveau de compression maximum**. C'est crucial car :

1. **Coh√©rence :** Pour qu'une attaque par know plaintext fonctionne, le fichier en clair doit √™tre compress√© avec **exactement le m√™me algorithme et les m√™mes param√®tres** que la version chiffr√©e.

2. **Niveaux de Compression ZIP :** ZIP utilise la compression DEFLATE avec des niveaux de 0 √† 9 :
   - `0` = pas de compression (stockage uniquement)
   - `1-8` = diff√©rents niveaux de compression
   - `9` = compression maximum (sortie la plus petite)

3. **Pourquoi la Compression Maximum ?** Lorsque quelqu'un prot√®ge des donn√©es sensibles par mot de passe, il veut g√©n√©ralement :
   - Une taille de fichier plus petite pour faciliter l'exfiltration
   - La compression maximale est un choix naturel
   - Le niveau `-9` est couramment utilis√© pour les archives importantes

4. **Exigences de l'Attaque :** Pour que bkcrack puisse trouver les cl√©s de chiffrement internes, il doit comparer les octets compress√©s en clair avec les octets chiffr√©s. Utiliser un mauvais niveau de compression rendrait les donn√©es compress√©es diff√©rentes, cassant l'attaque.

Le flag `-9` assure la compression maximale, correspondant √† ce qui a probablement √©t√© utilis√© dans l'archive originale.

---

### Crackage avec bkcrack

#### Installation de bkcrack

```bash
$ wget https://github.com/kimci86/bkcrack/releases/download/v1.8.1/bkcrack-1.8.1-Linux-x86_64.tar.gz
$ tar xzf bkcrack-1.8.1-Linux-x86_64.tar.gz
$ cd bkcrack-1.8.1-Linux-x86_64
```

#### R√©cup√©ration des Cl√©s de Chiffrement

Lan√ßons maintenant l'attaque :

```bash
$ ./bkcrack -C export.zip -c to-do_list.txt -P plain.zip -p to-do_list.txt
```

**Param√®tres expliqu√©s :**
- `-C export.zip` : L'archive chiffr√©e (Cipher)
- `-c to-do_list.txt` : Le fichier chiffr√© dans l'archive
- `-P plain.zip` : Notre archive en clair 
- `-p to-do_list.txt` : Le fichier en clair

**Sortie :**
```
bkcrack 1.8.1 - 2025-10-25
[10:34:32] Z reduction using 200 bytes of known plaintext
100.0 % (200 / 200)
[10:34:33] Attack on 40997 Z values at index 6
Keys: 31ab75f5 bdbb78b4 3a87f17c
70.3 % (28820 / 40997)
Found a solution. Stopping.
```

**Succ√®s !** Nous avons r√©cup√©r√© les cl√©s de chiffrement internes :
- `31ab75f5`
- `bdbb78b4`
- `3a87f17c`

#### D√©chiffrement de l'Archive

En utilisant les cl√©s r√©cup√©r√©es, nous pouvons d√©chiffrer l'archive enti√®re :

```bash
$ ./bkcrack -C export.zip -k 31ab75f5 bdbb78b4 3a87f17c -D decrypted.zip

bkcrack 1.8.1 - 2025-10-25
[10:37:57] Writing decrypted archive decrypted.zip
100.0 % (2 / 2)
```

```bash
$ unzip decrypted.zip
Archive:  decrypted.zip
replace to-do_list.txt? [y]es, [n]o, [A]ll, [N]one, [r]ename: y
  inflating: to-do_list.txt          
  inflating: Y2K_PATCH.bin
```

---

### Analyse du Patch Y2K

```bash
$ file Y2K_PATCH.bin
Y2K_PATCH.bin: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), 
dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
BuildID[sha1]=5a
for GNU/Linux 3.2.0, not stripped
```

Voyons ce que ce binaire contient :

```bash
$ strings -a Y2K_PATCH.bin
```

**Cha√Ænes cl√©s trouv√©es :**
```
Millennium Systems Y2K Patch v1.0
[*] Checking system date...
[!] Y2K anomaly detected
[*] Applying Epoch correction...
[!] Temporal buffer overflow
[!] Project 
poch channel opened
FLAG: HACKDAY{972c5106790706d6771242210703d58c6dd15484a47e3bf45bfa4c71d3df076d}
[*] Reboot required before 01/01/2000
```

**Flag:** `HACKDAY{972c5106790706d6771242210703d58c6dd15484a47e3bf45bfa4c71d3df076d}`

---

##  Mmh Delicious 

![ Mmh Delicious ](/assets/posts/hackday/mnh.png)

``File`` : [intercept.pcap](/assets/posts/hackday/intercept.pcap) 

### Challenge Description

> Hi‚Ä¶ A member of our team has been hacked‚Ä¶ He though he could download an agent to talk with... We need to make sure no important data has been leaked. Hopefully, we were able to capture his network traffic. Can you check this for us? I think it wasn't encrypted. 


### Initial Analysis

Le challenge nous fournit un fichier de capture r√©seau (PCAP) et mentionne qu'un membre de l'√©quipe a √©t√© compromis apr√®s avoir t√©l√©charg√© un "agent" pour communiquer. Notre objectif est d'identifier si des donn√©es sensibles ont √©t√© exfiltr√©es.

### Premi√®re approche : strings

J'ai d'abord tent√© d'extraire les cha√Ænes de caract√®res du fichier PCAP :
```bash
strings  -a intercept.pcap
```

Cette approche n'a pas r√©v√©l√© des donn√©es √©videntes imm√©diatement exploitables. Du moins je n'ai pas pris le temps de regarder attentivement.

---

### Investigation avec Wireshark

√âtant donn√© que la description mentionne des transmissions potentiellement malveillantes non chiffr√©es, j'ai ouvert le fichier dans Wireshark et commenc√© √† rechercher des termes suspects : `shell`, `system`, `php`.

### Filtrage sur "php"

En utilisant le filtre suivant dans Wireshark :
```
frame contains "php"
```

J'ai d√©couvert plusieurs requ√™tes HTTP vers `/telemetry.php` :
```
8597    72.813507    10.0.2.15    51.222.138.29    HTTP    166    HEAD /telemetry.php HTTP/1.1
10599   91.498905    10.0.2.15    51.222.138.29    HTTP    170    HEAD /telemetry.php HTTP/1.1
10754   116.195361   10.0.2.15    51.222.138.29    HTTP    186    HEAD /telemetry.php HTTP/1.1
11336   144.020500   10.0.2.15    51.222.138.29    HTTP    194    HEAD /telemetry.php HTTP/1.1
11547   181.250557   10.0.2.15    51.222.138.29    HTTP    258    HEAD /telemetry.php HTTP/1.1
```

Ces requ√™tes HEAD r√©p√©t√©es vers le m√™me endpoint semblaient suspectes.

---

En examinant de plus pr√®s ces requ√™tes HTTP, j'ai remarqu√© que certaines contenaient des cookies qui semblaient √™tre encod√©s en Base64.

![Cookie Analysis](/assets/posts/hackday/cookie.png)

### Extraction des cookies

Voici les cookies encod√©s que j'ai extraits :
```
session_id=ZG9uJ3QgZ21l2ZS0gQnlzTlY3lURGpbZVJHRVlGFuQ==
session_id=aGVsbG8gbWlzdHJhbCAh
session_id=d2hhdCB0aW1lIGlzIGl0Pw==
session_id=cmVtaW5kIG1lIG15IHN1cGVyIGltcG9ydGFudCByZXVuaW9uIGFib3V0IEhBQ0tEQVl7ODN3QVIzX1QwX0AhX0FnZU5UfSBpbiB0d28gaG91cnM=
```

---

### D√©codage Base64

J'ai proc√©d√© au d√©codage de chaque cookie en Base64 :
```bash
$ echo "aGVsbG8gbWlzdHJhbCAh" | base64 -d
hello mistral !

$ echo "d2hhdCB0aW1lIGlzIGl0Pw==" | base64 -d
what time is it?

$ echo "cmVtaW5kIG1lIG15IHN1cGVyIGltcG9ydGFudCByZXVuaW9uIGFib3V0IEhBQ0tEQVl7ODN3QVIzX1QwX0AhX0FnZU5UfSBpbiB0d28gaG91cnM=" | base64 -d
remind me my super important reunion about HACKDAY{83wAR3_T0_@!_AgeNT} in two hours
```

---

### Solution

Le flag √©tait cach√© dans le dernier cookie.
```
remind me my super important reunion about HACKDAY{83wAR3_T0_@!_AgeNT} in two hours
```

**Flag:** `HACKDAY{83wAR3_T0_@!_AgeNT}`

---


## Jack in with Chaptain  

![ Jack in with Chaptain ](/assets/posts/hackday/jack.png)

``File`` : [jackingin.zip](/assets/posts/hackday/jackingin.zip) 

### Challenge Description

> To connect to the Matrix, Neo and his friends are using a new portal for jacking in. However, a legacy portal that's vulnerable remains active. Recently, someone has successfully accessed the system through it, and you need to identify the user.

> Format du flag: `HACKDAY{secret@user@password}`

---

Commen√ßons par examiner le fichier `gateway.bak`:

```bash
cat gateway.bak 
```
C'est du base64 une fois d√©cod√© Voici les sections cl√©s:

#### Configuration L2TP
```xml
<l2tp>
    <radius>
        <server>192.168.58.101</server>
        <secret>123456</secret>
    </radius>
    <paporchap>pap</paporchap>
    <secret>123456</secret>
    <user>
        <name>testvpn</name>
        <password><![CDATA[vpntest]]></password>
    </user>
</l2tp>
```

#### Serveurs d'Authentification RADIUS

**1. NPS-AD-VPN (S√©curis√©):**
```xml
<authserver>
    <name>NPS-AD-VPN</name>
    <radius_protocol>MSCHAPv2</radius_protocol>
    <host>192.168.58.101</host>
    <radius_secret>feaab218965ede0008b0aa704a0a53e5ba0dfc3a</radius_secret>
</authserver>
```

**2. NPS-AD-Legacy (Vuln√©rable):**
```xml
<authserver>
    <name>NPS-AD-Legacy</name>
    <radius_protocol>PAP</radius_protocol>
    <host>192.168.58.101</host>
    <!-- Rotation to the forbidden --!>
    <radius_secret>Y3t4plBar!fa3b</radius_secret>
</authserver>
```

### üîë Observation

Le commentaire `<!-- Rotation to the forbidden -->`  !. En appliquant le rot13 la cl√© secr√®te devient : L3g4syOne!sn3o

### Comprendre la Vuln√©rabilit√©

**PAP vs MSCHAPv2:**

| Protocole | Niveau de S√©curit√© | Description |
|----------|-------------------|-------------|
| **MSCHAPv2** | ‚úÖ S√©curis√© | Authentification challenge-response, mots de passe hash√©s |
| **PAP** | ‚ùå Vuln√©rable | Mot de passe seulement XOR√© avec MD5(secret + authenticator) |

**Pourquoi PAP est vuln√©rable:**
- Les mots de passe sont seulement chiffr√©s par XOR
- Si vous connaissez le secret partag√© RADIUS, vous pouvez d√©chiffrer les mots de passe

---

### Scan Initial du PCAP

Cr√©ons un script Python pour scanner le trafic RADIUS voous pouvez directement le faire avec wireshark si vous preferez:

```python
import dpkt
import socket

with open('LAN_Traffic.pcap', 'rb') as f:
    pcap = dpkt.pcap.Reader(f)
    
    for ts, buf in pcap:
        eth = dpkt.ethernet.Ethernet(buf)
        
        if isinstance(eth.data, dpkt.ip.IP):
            ip = eth.data
            
            if isinstance(ip.data, dpkt.udp.UDP):
                udp = ip.data
                
                # RADIUS utilise les ports 1812 (auth) et 1813 (accounting)
                if udp.dport == 1812 or udp.sport == 1812:
                    print(f"Paquet RADIUS trouv√© !")
                    print(f"Source: {socket.inet_ntoa(ip.src)}:{udp.sport}")
                    print(f"Dest: {socket.inet_ntoa(ip.dst)}:{udp.dport}")
```

**R√©sultat:** Plusieurs paquets RADIUS entre `192.168.58.254` (pfSense) et `192.168.58.101` (serveur RADIUS)

---

### Comprendre les Attributs RADIUS

Le protocole RADIUS utilise des **attributs** pour transporter l'information:

| Type d'Attribut | Nom | Description |
|----------------|-----|-------------|
| 1 | User-Name | Nom d'utilisateur |
| 2 | User-Password | Mot de passe PAP (vuln√©rable!) |
| 26 | Vendor-Specific | Utilis√© par MS-CHAP |

### Parser les Paquets RADIUS
```python
# Structure d'un paquet RADIUS:
# Octet 0: Code (1=Access-Request, 2=Access-Accept, 3=Access-Reject)
# Octet 1: Identifier
# Octets 2-3: Longueur
# Octets 4-19: Authenticator (16 octets)
# Octets 20+: Attributs

# Parser les attributs
offset = 20  # Les attributs commencent apr√®s l'en-t√™te
while offset < len(data):
    attr_type = data[offset]
    attr_len = data[offset + 1]
    attr_value = data[offset + 2:offset + attr_len]
    
    if attr_type == 1:  # User-Name
        username = attr_value.decode('utf-8')
    elif attr_type == 2:  # User-Password (PAP!)
        encrypted_password = attr_value
    
    offset += attr_len
```

### Utilisateurs Trouv√©s dans le Trafic

Lors de notre analyse, nous avons trouv√© ces utilisateurs:

- **trinity** (MS-CHAP) ‚úÖ
- **tank** (MS-CHAP) ‚úÖ
- **theoracle** (MS-CHAP) ‚úÖ
- **cypher** (MS-CHAP + tentatives PAP) ‚ö†Ô∏è
- **neo** (MS-CHAP) ‚úÖ
- **n3o** (MS-CHAP + PAP) ‚ö†Ô∏è
- **switch** (MS-CHAP) ‚úÖ
- **morpheus** (MS-CHAP) ‚úÖ

---

### Codes de R√©ponse RADIUS

| Code | Type | Signification |
|------|------|--------------|
| 1 | Access-Request | Tentative d'authentification |
| 2 | Access-Accept | ‚úÖ Authentification r√©ussie |
| 3 | Access-Reject | ‚ùå Authentification √©chou√©e |

### Script pour Trouver les Connexions PAP R√©ussies
```python
import dpkt
import struct

requests = {}   # identifier -> d√©tails de la requ√™te
responses = {}  # identifier -> ACCEPT / REJECT

with open('LAN_Traffic.pcap', 'rb') as f:
    pcap = dpkt.pcap.Reader(f)

    for ts, buf in pcap:
        eth = dpkt.ethernet.Ethernet(buf)

        if not isinstance(eth.data, dpkt.ip.IP):
            continue
        ip = eth.data

        if not isinstance(ip.data, dpkt.udp.UDP):
            continue
        udp = ip.data

        if udp.dport != 1812 and udp.sport != 1812:
            continue

        data = udp.data
        if len(data) < 20:
            continue  # header RADIUS incomplet

        code = data[0]
        identifier = data[1]
        radius_len = struct.unpack("!H", data[2:4])[0]
        authenticator = data[4:20]

        # s√©curit√© : tronquer √† la longueur RADIUS annonc√©e
        if radius_len > len(data):
            # paquet tronqu√© ou capture incompl√®te
            continue
        data = data[:radius_len]

        # Parser les attributs
        username = None
        encrypted_pw = None
        auth_type = "Unknown"

        offset = 20
        while offset + 2 <= len(data):
            attr_type = data[offset]
            attr_len = data[offset + 1]
            if attr_len < 2 or offset + attr_len > len(data):
                break

            attr_value = data[offset + 2: offset + attr_len]

            if attr_type == 1:  # User-Name
                try:
                    username = attr_value.decode('utf-8', errors='replace')
                except Exception:
                    username = repr(attr_value)
            elif attr_type == 2:  # User-Password (PAP, chiffr√© RADIUS)
                encrypted_pw = attr_value
                auth_type = "PAP"
            elif attr_type == 26:  # Vendor-Specific 
                auth_type = "MS-CHAP"

            offset += attr_len

        # RADIUS codes: 1=Request, 2=Accept, 3=Reject
        if code == 1 and auth_type == "PAP":
            requests[identifier] = {
                "username": username,
                "encrypted_pw": encrypted_pw,
                "authenticator": authenticator
            }
        elif code == 2 and identifier in requests:
            responses[identifier] = "ACCEPT"
        elif code == 3 and identifier in requests:
            responses[identifier] = "REJECT"

print(f"Requ√™tes PAP trouv√©es: {len(requests)}")
print(f"R√©ponses associ√©es (ACCEPT/REJECT): {len(responses)}")

# Afficher les r√©sultats
for ident, req in requests.items():
    status = responses.get(ident, "NO_RESPONSE")
    print(f"[id={ident:3}] user={req['username']} -> {status}")


 
```

### üéØ R√©sultat

**L'utilisateur `n3o` s'est authentifi√© avec succ√®s en utilisant PAP !**

**D√©tails du paquet:**
- **Nom d'utilisateur:** `n3o`
- **Identifier:** `233` (0xE9)
- **Authenticator:** `dafdd437e23dd7bc8dafc4893031c2ac`
- **Mot de passe chiffr√©:** `498817d0d24b7bc90b7ad894a63b8010`
---

## D√©chiffrement du Mot de Passe PAP

### Comprendre l'Algorithme PAP (RFC 2865)

PAP chiffre les mots de passe en utilisant cet algorithme simple:
```
1. Padding du mot de passe √† un multiple de 16 octets avec des octets nuls
2. Pour le premier bloc (16 octets):
   b1 = MD5(secret + Request_Authenticator)
   c1 = p1 XOR b1
3. Pour d√©chiffrer:
   p1 = c1 XOR b1
```

**Repr√©sentation visuelle:**
```
Secret:        L3g4syOne!sn3o
Authenticator: dafdd437e23dd7bc8dafc4893031c2ac
                    ‚Üì
            MD5(secret + authenticator)
                    ‚Üì
                Hash MD5
                    ‚Üì
    Mot de passe chiffr√© XOR Hash MD5
                    ‚Üì
          Mot de passe en clair
```


### D√©chiffrement 
```python
import hashlib

authenticator = bytes.fromhex('dafdd437e23dd7bc8dafc4893031c2ac')
encrypted_pw = bytes.fromhex('498817d0d24b7bc90b7ad894a63b8010')
secret = 'L3g4syOne!sn3o'  

# D√©chiffrement PAP
md5_hash = hashlib.md5(secret.encode() + authenticator).digest()
decrypted = bytes(x ^ y for x, y in zip(encrypted_pw, md5_hash))

# Retirer le padding null
password = decrypted.rstrip(b'\x00').decode('utf-8')

print(f"Mot de passe: {password}")
```

**R√©sultat:**
```
Mot de passe: ImTheOne4242!!
```

‚úÖ **Succ√®s !** Le mot de passe est lisible et fait r√©f√©rence √† Matrix (Neo est "The One") !

---

### Construction du Flag

Format du flag: `HACKDAY{secret@user@password}`

**Composants:**
- **Secret:** `L3g4syOne!sn3o` (apr√®s ROT13)
- **Utilisateur:** `n3o`
- **Mot de passe:** `ImTheOne4242!!`

### üö© Flag Final
```
HACKDAY{L3g4syOne!sn3o@n3o@ImTheOne4242!!}
```
---


## Find me

![ Find me ](/assets/posts/hackday/findme.png)

`File` : [image.qcow2](https://drive.google.com/file/d/1wvawhon7BO_krMoSNt8ZjaMhtw5azcXp/edit)

### Challenge Description

> My little brother has been playing with the family computer again. I don't know what he did, but he opened a black window with lots of green text and started banging away at the keyboard, saying he was "coding a video game".

> Now I can't find the files anywhere.


Le challenge nous donne une image disque QCOW2.
```bash
$ file image.qcow2
image.qcow2: QEMU QCOW Image (v3), 21474836480 bytes
```

Quand j'ai une image pour une analyse forensic je commence toujours par faire des greps et strings pour voir un peu :

```bash
$ strings -a image.qcow2 | grep -i HACKDAY
HACKDAY{
```
 Utilisons `ripgrep` (rg) ou `grep` avec l'option `-a` :

```bash
$ rg -a HACKDAY image.qcow2
HACKDAY{bcd0d684805c5d5024aeb5b069bc51aa4971dcfbc64551ef599c73b05d016f90}
```

Ou avec `grep` :

```bash
$ grep -a HACKDAY image.qcow2
HACKDAY{bcd0d684805c5d5024aeb5b069bc51aa4971dcfbc64551ef599c73b05d016f90}
```

üö© **Flag trouv√© !**

---

### Flag

```
HACKDAY{bcd0d684805c5d5024aeb5b069bc51aa4971dcfbc64551ef599c73b05d016f90}
```

*Ce n'est evidemment pas la solution attendu. normally the real intended solution was to fix the inode 61789 ... ü•≤
with debugfs*


# Steganography

## Wait A Bit
![ Wait A Bit ](/assets/posts/hackday/waitabit.png)

``File`` : [eMule_Optimizer](/assets/posts/hackday/eMule_Optimizer) 

### Challenge Description

> The endless wait for your music to download via eMule led you to eMule_Optimizer‚Ä¶ But it seems that it is not working as expected‚Ä¶ Moreover, a multitude of instructions seem to have been ADDED to this otherwise simple code‚Ä¶ There must be something hidden. 

### Initial Analysis

Le challenge nous fournit un binaire Linux nomm√© `eMule_Optimizer`. Commen√ßons par analyser le fichier :

```bash
$ file eMule_Optimizer
eMule_Optimizer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), 
dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
BuildID[sha1]=131e9022422fe1a8a758777e30d4ccf745102fba, 
for GNU/Linux 3.2.0, not stripped
```

C'est un ex√©cutable 64-bit Linux **non stripp√©**, ce qui signifie que les symboles de d√©bogage sont pr√©sents.

### Ex√©cution du binaire

```bash
$ ./eMule_Optimizer
Don't execute what u find on internet !!
```

Le programme affiche simplement un message d'avertissement et se termine. Rien de particuli√®rement int√©ressant √† premi√®re vue.

---

### Analyse des fonctions

 Je lance gdb pour une analyse manuelle. 
 En d√©sassemblant le `mÃÄain` on voit qu'il fait juste un appel √† une autre fonction `silence`

```bash
$ gdb ./eMule_Optimizer
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x0000000000001000  _init
0x0000000000001040  __cxa_finalize@plt
0x0000000000001050  puts@plt
0x0000000000001060  _start
0x0000000000001090  deregister_tm_clones
0x00000000000010c0  register_tm_clones
0x0000000000001100  __do_global_dtors_aux
0x0000000000001140  frame_dummy
0x0000000000001149  silence          ‚Üê Notre cible
0x0000000000001fec  main
0x0000000000002014  _fini

(gdb) disass silence
```

En regardant le d√©sassemblage, quelque chose saute imm√©diatement aux yeux : **une multitude d'instructions NOP** (`0x90`) dispers√©es dans le code !

```nasm
1166:   8b 55 f8                mov    -0x8(%rbp),%edx
1169:   8b 45 f4                mov    -0xc(%rbp),%eax
116c:   01 d0                   add    %edx,%eax
116e:   89 45 f4                mov    %eax,-0xc(%rbp)
1171:   8b 55 fc                mov    -0x4(%rbp),%edx
1174:   8b 45 f8                mov    -0x8(%rbp),%eax
1177:   01 d0                   add    %edx,%eax
1179:   90                      nop     ‚Üê Suspect !
117a:   89 45 f8                mov    %eax,-0x8(%rbp)
```

---

### Comptage des NOPs

Comptons combien de NOPs se trouvent dans cette fonction :

```bash
$ objdump -d eMule_Optimizer | grep -A 3000 "<silence>" | grep "nop" | wc -l
98
```

**98 instructions NOP** dans une seule fonction ! C'est anormal. Les NOPs (No Operation) sont g√©n√©ralement utilis√©s pour l'alignement m√©moire, mais en si grande quantit√©, c'est suspect.


```bash
$ objdump -d eMule_Optimizer | grep -A 3000 "" | grep "imul" | wc -l
35
```

On observe √©galement **35 instructions `imul`** qui semblent d√©limiter des blocs ou "rounds" dans le code.

---

### Hypoth√®se : Steganographie par NOP

**Steganographie NOP** : Une technique qui consiste √† cacher des donn√©es dans du code en ins√©rant strat√©giquement des instructions NOP. Ces instructions :
- N'affectent **pas** le comportement du programme (elles ne font rien)
- Peuvent encoder des **bits d'information** par leur pr√©sence ou absence

---

### Identification du pattern

En analysant plus attentivement le code, j'ai remarqu√© que les NOPs apparaissent souvent apr√®s des instructions `add %edx,%eax` :

```nasm
; Exemple 1
add    %edx,%eax
nop              ‚Üê Bit 1 ?

; Exemple 2  
add    %edx,%eax
mov    %eax,-0x8(%rbp)  ‚Üê Pas de NOP, bit 0 ?
```

Les 35 instructions `imul` semblent d√©limiter des "rounds" ou blocs logiques. Chaque round contient plusieurs instructions `add`, certaines suivies de NOP, d'autres non.

---

### Script d'extraction

J'ai √©crit un script Python pour automatiser l'extraction des bits :

```python
#!/usr/bin/env python3
import re
import subprocess
import sys


def extract_silence_function(binary_path):
    with open(binary_path, 'rb') as f:
        data = f.read()
    
    # Offsets de la fonction silence
    SILENCE_START = 0x1149
    SILENCE_END = 0x1feb
    silence_code = data[SILENCE_START:SILENCE_END]
    
    # Sauvegarder dans un fichier temporaire
    temp_file = "/tmp/silence.bin"
    with open(temp_file, 'wb') as f:
        f.write(silence_code)
    
    return temp_file


def disassemble_function(bin_file):
    """D√©sassemble avec objdump"""
    result = subprocess.check_output(
        ["objdump", "-D", "-b", "binary", "-m", "i386:x86-64", bin_file],
        text=True,
        stderr=subprocess.DEVNULL
    )
    
    instructions = []
    for line in result.splitlines():
        match = re.match(r"\s*([0-9a-f]+):\s+([0-9a-f ]+)\s+\t(.+)", line)
        if match:
            offset = int(match.group(1), 16)
            asm = match.group(3).strip()
            instructions.append((offset, asm))
    
    return instructions


def extract_bits_from_nop_pattern(instructions):
    """
    Extrait les bits en analysant les blocs d√©limit√©s par 'imul'
    """
    # Trouver les positions des 'imul' (d√©limiteurs de rounds)
    imul_positions = [
        i for i, (_, asm) in enumerate(instructions) 
        if asm.startswith("imul")
    ]
    
    print(f"[+] {len(imul_positions)} rounds d√©tect√©s")
    
    bits = []
    
    # Pour chaque round
    for round_idx in range(len(imul_positions)):
        start = 0 if round_idx == 0 else imul_positions[round_idx - 1] + 1
        end = imul_positions[round_idx] + 1
        
        round_instructions = instructions[start:end]
        
        # Analyser chaque instruction du round
        for i in range(len(round_instructions) - 1):
            current_asm = round_instructions[i][1]
            next_asm = round_instructions[i + 1][1]
            
            # Pattern cl√©: instructions 'add' manipulant %eax
            if current_asm.startswith("add") and "%eax" in current_asm:
                bit = 1 if next_asm == "nop" else 0
                bits.append(bit)
    
    return bits


def decode_bits_to_ascii(bits):
    """Convertit les bits en ASCII (MSB first)"""
    text = ""
    
    for i in range(0, len(bits) - 7, 8):
        byte_bits = bits[i:i+8]
        byte_value = int(''.join(map(str, byte_bits)), 2)
        
        if 32 <= byte_value < 127:
            text += chr(byte_value)
        else:
            text += f"[{byte_value:02x}]"
    
    return text


def main():
    binary_path = "eMule_Optimizer"
    
    print("="*70)
    print(" "*20 + "Wait A Bit - Solver")
    print("="*70)
    
    # Extraction
    print("\n[1] Extraction de la fonction 'silence'...")
    silence_bin = extract_silence_function(binary_path)
    
    # D√©sassemblage
    print("[2] D√©sassemblage...")
    instructions = disassemble_function(silence_bin)
    print(f"    ‚Üí {len(instructions)} instructions")
    
    # Extraction des bits
    print("\n[3] Extraction des bits...")
    bits = extract_bits_from_nop_pattern(instructions)
    print(f"    ‚Üí {len(bits)} bits extraits")
    print(f"    ‚Üí Ones: {sum(bits)}, Zeros: {len(bits) - sum(bits)}")
    
    # D√©codage
    print("\n[4] D√©codage...")
    flag = decode_bits_to_ascii(bits)
    
    print(f"\n{'='*70}")
    print("FLAG TROUV√â!")
    print("="*70)
    print(f"\n{flag}\n")


if __name__ == "__main__":
    main()
```

---

### Ex√©cution du script

```bash
$ python3 solve.py

[1] Extraction de la fonction 'silence'...
[2] D√©sassemblage...
    ‚Üí 1370 instructions

[3] Extraction des bits...
[+] 35 rounds d√©tect√©s
    ‚Üí 242 bits extraits
    ‚Üí Ones: 98, Zeros: 144

[4] D√©codage...

======================================================================
FLAG TROUV√â!
======================================================================

HACKDAY{n0P_!s_th3_NeW_1}
```

---

**Flag:** `HACKDAY{n0P_!s_th3_NeW_1}`



## Polyglot 
![ Polyglot  ](/assets/posts/hackday/polyglot.png)

``File`` : [challenge.pdf](/assets/posts/hackday/challenge.pdf) 

### Challenge Description

>  It must be so cool to be able to read all those types of languages!

On nous fournit un fichier `challenge.pdf`. Le titre "Polyglot" est un indice : un fichier polyglot est un fichier valide dans plusieurs formats simultan√©ment.

Commen√ßons par une analyse basique du fichier :

```bash
$ file challenge.pdf
challenge.pdf: PDF document, version 1.7, 20 page(s)
```

Le fichier est bien reconnu comme un PDF valide. Mais creusons plus loin...

### Analyse avec pdf-parser

Utilisons `pdf-parser` pour examiner la structure interne du PDF :

```bash
$ pdf-parser --stats challenge.pdf
Comment: 14
XREF: 0
Trailer: 0
StartXref: 1
Indirect object: 402
Indirect objects with a stream: 9, 12, 17, 20, 25, 28, 33, 36, 41, 44, ...
/Catalog 1: 1
/Font 32: 5, 13, 21, 29, 37, 45, ...
/Page 42: 3, 55, 56, 131, 132, ...
/Pages 4: 2, 399, 400, 398
/Stream 32: 9, 17, 25, 33, 41, 49, ...
/XObject 13: 53, 114, 115, 116, 117, ...
/XRef 1: 402
Unreferenced indirect objects: 402 0 R
```

Le PDF semble normal avec ses 42 pages et ses diff√©rents objets. Mais regardons de plus pr√®s avec `binwalk`.

### Extraction avec binwalk

```bash
$ binwalk -e challenge.pdf

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
186           0xBA            Zlib compressed data, default compression
46966         0xB776          Zlib compressed data, default compression
[... nombreux streams Zlib - normal pour un PDF ...]
2406880       0x24B9E0        Zip archive data, at least v2.0 to extract, 
                              compressed size: 8107, uncompressed size: 16446, 
                              name: flag.png
```
 √Ä l'offset `0x24B9E0` (2406880 en d√©cimal), binwalk d√©tecte une archive ZIP contenant un fichier `flag.png`. C'est la signature d'un **polyglot PDF/ZIP**.

### Compr√©hension du polyglot PDF/ZIP

Un fichier polyglot PDF/ZIP exploite le fait que :
- **PDF** lit le fichier depuis le **d√©but** (cherche `%PDF` au d√©but)
- **ZIP** lit le fichier depuis la **fin** (le "Central Directory" est √† la fin)

Ainsi, on peut avoir un fichier qui est simultan√©ment un PDF valide ET un ZIP valide !

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  %PDF-1.7                                       ‚îÇ  ‚Üê PDF header
‚îÇ  ... contenu PDF ...                            ‚îÇ
‚îÇ  ... objets, streams, pages ...                 ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ  PK... (ZIP local file header)          ‚îÇ    ‚îÇ  ‚Üê ZIP data
‚îÇ  ‚îÇ  flag.png (compressed)                  ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  PK... (Central Directory)              ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  PK... (End of Central Directory)       ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  %%EOF                                          ‚îÇ  ‚Üê PDF footer
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Extraction du flag

### M√©thode 1 : Extraction directe avec unzip

Le plus simple est de traiter le PDF comme un ZIP :

```bash
$ unzip challenge.pdf
Archive:  challenge.pdf
  inflating: flag.png
```

### M√©thode 2 : Via binwalk

Si l'extraction directe √©choue, on peut utiliser les fichiers extraits par binwalk :

```bash
$ cd _challenge.pdf.extracted
$ ls | grep zip
24B9E0.zip

$ unzip 24B9E0.zip
error [24B9E0.zip]: missing 2406880 bytes in zipfile
(attempting to process anyway)
error: invalid zip file with overlapped components (possible zip bomb)
```

L'extraction avec `unzip` √©choue car le fichier extrait n'a pas le contexte complet. Utilisons `7z` qui est plus tol√©rant :

```bash
$ 7z x 24B9E0.zip

7-Zip 25.01 (x64)
Extracting archive: 24B9E0.zip
Path = 24B9E0.zip
Type = zip
Offset = -2406880
Physical Size = 2415153
Embedded Stub Size = 2406880

Everything is Ok
Size:       16446
Compressed: 8273
```

En ouvrant l'image `flag.png`, on obtient :

![Flag](/assets/img/ctf/hackday2026/flag.png)

### Flag

```
HACKDAY{FiLes_can_B3_PolY6LOT}
```

## Deep Filter
![ Deep Filter  ](/assets/posts/hackday/deepFilter.png)

``File`` : [logo.png](/assets/posts/hackday/logo.png) 

### Challenge Description

>  Yo, listen up. We've got a fresh drop from a former Tecktonik Krew member. He was apparently also a low-level data courier for a shadow organization, and he's vanished. All we've got is this strangly compressed PNG, his last known upload.


Je commence par les v√©rifications classiques :

```bash
$ file logo.png
logo.png: PNG image data, 250 x 275, 8-bit/color RGB, non-interlaced

$ strings logo.png | grep -i hack
# Rien...

$ binwalk logo.png
# Pas de fichiers cach√©s
```


J'ai √©galement test√© les outils habituels : `zsteg`, `stegsolve`, `aperisolve` analyse des LSB... Rien de concluant.

### L'indice dans le titre

Le nom du challenge est **"Deep Filter"** et l'√©nonc√© mentionne un PNG "strangely compressed". Ces deux indices pointent vers quelque chose de sp√©cifique au format PNG : **les filtres de ligne**.

---

### Comment fonctionne la compression PNG

Le format PNG utilise un syst√®me de filtrage avant la compression zlib. Chaque **ligne** de l'image est pr√©c√©d√©e d'un **octet de filtre** qui indique comment les pixels de cette ligne sont encod√©s :

| Valeur | Type de filtre | Description |
|--------|---------------|-------------|
| 0 | None | Pas de filtrage |
| 1 | Sub | Diff√©rence avec le pixel de gauche |
| 2 | Up | Diff√©rence avec le pixel du dessus |
| 3 | Average | Moyenne des pixels gauche et dessus |
| 4 | Paeth | Pr√©dicteur de Paeth |

Ces filtres optimisent la compression en r√©duisant la redondance des donn√©es. **Les valeurs valides sont uniquement 0 √† 4.**

### Structure des donn√©es d√©compress√©es

Pour une image RGB de 250√ó275 pixels :
- Chaque pixel = 3 octets (R, G, B)
- Chaque ligne = 1 octet (filtre) + 250 √ó 3 octets (pixels) = **751 octets**
- Total = 275 lignes √ó 751 octets = **206 525 octets**

---

### Extraction et analyse des filtres

J'ai √©crit un script Python pour extraire et analyser les filter bytes :

```python
import zlib
import struct

with open('logo.png', 'rb') as f:
    data = f.read()

# Parser les chunks PNG pour extraire IDAT
pos = 8  # Skip PNG signature (89 50 4E 47 0D 0A 1A 0A)
idat_data = b''

while pos < len(data):
    length = struct.unpack('>I', data[pos:pos+4])[0]
    chunk_type = data[pos+4:pos+8]
    
    if chunk_type == b'IDAT':
        idat_data += data[pos+8:pos+8+length]
    
    pos += 12 + length  # 4 (length) + 4 (type) + length + 4 (CRC)

# D√©compresser les donn√©es
decompressed = zlib.decompress(idat_data)
print(f"Taille d√©compress√©e : {len(decompressed)} octets")

# Param√®tres de l'image
width, height = 250, 275
row_size = 1 + width * 3  # 751 octets par ligne

# Extraire le filter byte de chaque ligne
filter_bytes = []
for row in range(height):
    filter_byte = decompressed[row * row_size]
    filter_bytes.append(filter_byte)

# Analyser les valeurs
print(f"Valeurs uniques : {set(filter_bytes)}")
print(f"Premiers filtres : {filter_bytes[:50]}")
```

### R√©sultat surprenant

```
Taille d√©compress√©e : 206525 octets
Valeurs uniques : {1, 2}
Premiers filtres : [1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2]
    
```
 Les filtres ne prennent que deux valeurs : **1 et 2**. C'est  suspect ! 

Normalement, un encodeur PNG choisit le filtre optimal pour chaque ligne (celui qui donne la meilleure compression). Avoir uniquement des 1 et des 2 sur 275 lignes es improbable... sauf si c'est volontaire.

---

### Hypoth√®se : encodage binaire

Avec seulement deux valeurs possibles, l'hypoth√®se la plus √©vidente est un **encodage binaire** :
- Filtre **1** ‚Üí bit **0**
- Filtre **2** ‚Üí bit **1**

### Script de d√©codage

```python
import zlib
import struct

with open('logo.png', 'rb') as f:
    data = f.read()

# Extraction des donn√©es IDAT
pos = 8
idat_data = b''
while pos < len(data):
    length = struct.unpack('>I', data[pos:pos+4])[0]
    chunk_type = data[pos+4:pos+8]
    if chunk_type == b'IDAT':
        idat_data += data[pos+8:pos+8+length]
    pos += 12 + length

# D√©compression
decompressed = zlib.decompress(idat_data)

# Param√®tres
width, height = 250, 275
row_size = 1 + width * 3

# Extraction des filter bytes
filter_bytes = [decompressed[row * row_size] for row in range(height)]

# Conversion en binaire : 1 -> '0', 2 -> '1'
binary_string = ''.join('0' if b == 1 else '1' for b in filter_bytes)
print(f"Binaire : {binary_string[:64]}...")

# Conversion binaire -> ASCII
flag = ''
for i in range(0, len(binary_string) - 7, 8):
    byte_value = int(binary_string[i:i+8], 2)
    if byte_value > 0:  # Ignorer les null bytes
        flag += chr(byte_value)

print(f"Flag : {flag}")
```

### R√©sultat

```
Binaire : 0100100001000001010000110100101101000100010000010101100101111011...
Flag : HACKDAY{S0_MuCh_D4T4_!N_PnG}
```

---

### Flag

```
HACKDAY{S0_MuCh_D4T4_!N_PnG}
```

---




##  The Glitch in the Matrix 
![  The Glitch in the Matrix   ](/assets/posts/hackday/glitch.png)

``File`` : [Matrix_challenge.png](/assets/posts/hackday/Matrix_challenge.png) 

### Challenge Description

>  The simulation is starting to fracture, and Neo can finally see the raw data stream behind the reality. During a "bullet time" glitch, he noticed that the truth isn't hidden in the whole image, but scattered within the tiniest fragments of the red signals.

> Morpheus left a final transmission: "To escape, you must look closely at the red pill. Collect its smallest units of information and regroup them 8 by 8 to reconstruct the message. But remember, the signal is still distorted. Only the Answer to the Ultimate Question of Life, the Universe, and Everything can unmask the final secret".

